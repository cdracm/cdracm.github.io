---
layout: post
title: "Hard and Rigid is better than Soft and Limp"
---

It was one of my longest bug-hunting journeys, even though it was ridden with a higher-than-usual amount of stupidity.

__First__, I had to convince myself the bug was there. That took an indecent amount of time.

The bug [IJPL-177151 Incorrect highlighting when commenting](https://youtrack.jetbrains.com/issue/IJPL-177151/Incorrect-highlighting-when-commenting)
complained that sometimes, when the user typed into the IDE editor, the comments in the code were highlighted not as grayed-out text, but as the code that was commented out.

E.g., this is correct, everything is grey:
![](assets/comments_correct.png)

But sometimes, they say, this horror happens. Which is incorrect, because some other colors leaked inside the comments :
![](assets/comments_incorrect.png)

Of course, all programmers know that the most probable explanations are:
- CMB radiation from the Big Bang flipped a couple of memory transistors
- The previous OutOfMemoryError corrupted some internal state
- The JDK is too old, or too new, depending.

Unfortunately, one evening I did witness this bug myself, which meant it was real, and I had to skip to the fifth acceptance stage instantly.
I had to fix it.

__Then__ I needed a way to reproduce it.
But it was not reproducible.
However long I furiously typed, there was not a single issue.
I wrote a handful of stress tests that typed into a file and checked that highlighting was correct.
Nothing.

I created a horribly convoluted test file containing dozens of lambdas nesting inside anonymous classes and tortured it, without success.
Weeks passed.
I kept this file in my repository, just in case, typing there from time to time, trying to catch inconsistent highlighting.
It worked flawlessly without any problems.

Until one late evening I desperately opened this test file again one last time before leaving home - and there it was, inconsistent highlighting inside the comments.
Yes, the bug definitely was there.
And it also seemed to happen after some significant idle time. Usually, when I typed, and typed, and typed some more, the bug never did trigger.
However, when I typed something and left the file alone for a day, then typed some more, the bug was sometimes there.
OK, that was something.

Unfortunately, I needed to reproduce the very specific moment when the highlighting became incorrect; otherwise, it was too late.
But what did this behaviour remind me of?

Garbage fucking collection!
The garbage collector in the JVM works in a similar way: when some memory becomes unreferenced, it gets garbage-collected after some time.
How could I induce the garbage collector to fire more often?

I tried typing violently in my artificially complex test file while invoking the "garbage collect" action simultaneously.
It helped.
Now it required just five minutes of continuously clicking the "Garbage Collect" button with the mouse in my right hand, while
my left hand was hmm... occupied with the other... activity... of... rigorously... tightly... mmm... energetically...
typing random characters into the editor.

And yes, after I enabled all possible logging with level = ULTRA_FINEST_RUSTLING, there it was:

```
2025-12-16 14:18:17,407 [76242521]  WHISPER - #c.i.c.d.i.HighlightInfoUpdaterImpl - psiElementVisited: PsiReferenceExpression:evicted(6972,6979) {1771668446}class com.intellij.psi.impl.source.tree.java.PsiReferenceExpressionImpl; tool:class com.intellij.codeInsight.daemon.impl.analysis.JavaNamesHighlightVisitor; infos:[HighlightInfo(6972,6979); text='evicted'; highlighter: (6972,6979); severity=SYMBOL_TYPE_SEVERITY(8); toolId: class com.intellij.codeInsight.daemon.impl.analysis.JavaNamesHighlightVisitor]; oldInfos:[HighlightInfo(6972,6979); severity=SYMBOL_TYPE_SEVERITY(8); toolId: class com.intellij.codeInsight.daemon.impl.analysis.JavaNamesHighlightVisitor] 368637298V
2025-12-16 14:18:17,407 [76242521]  WHISPER - #c.i.c.d.i.HighlightInfoUpdaterImpl - assignRangeHighlighters: pickedup InvalidPsi(PsiJavaCodeReferenceElement:NotNull(7005,7012) {163348086}class com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl,HighlightInfo(7004,7012); text='@NotNull'; highlighter: (7004,7012); severity=SYMBOL_TYPE_SEVERITY(8); toolId: class com.intellij.codeInsight.daemon.impl.analysis.JavaNamesHighlightVisitor; forcedTextAttributes: [fore=java.awt.Color[r=158,g=136,b=13], back=null, type=0, effect=BOXED]) from recycler 368637298V
2025-12-16 14:18:17,407 [76242521]  WHISPER - #c.i.c.d.i.HighlightInfoUpdaterImpl - changeRangeHighlighterAttributes: (recycled)HighlightInfo(7004,7012); text='@NotNull'; highlighter: (7004,7012); severity=SYMBOL_TYPE_SEVERITY(8); toolId: class com.intellij.codeInsight.daemon.impl.analysis.JavaNamesHighlightVisitor; forcedTextAttributes: [fore=java.awt.Color[r=158,g=136,b=13], back=null, type=0, effect=BOXED] 368637298V
2025-12-16 14:18:17,407 [76242521]  WHISPER - #c.i.c.d.i.HighlightInfoUpdaterImpl - removeFromDataAtomically: PsiJavaCodeReferenceElement:NotNull(7005,7012) {163348086}class com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl: old=1; new=0 368637298V
2025-12-16 14:18:17,407 [76242521]  WHISPER - #c.i.c.d.i.HighlightInfoUpdaterImpl - psiElementEvictionListener: 0
2025-12-16 14:18:17,407 [76242521]  WHISPER - #c.i.c.d.i.HighlightInfoUpdaterImpl - psiElementVisited: PsiJavaCodeReferenceElement:NotNull(7005,7012) {163348086}class com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl; tool:class com.intellij.codeInsight.daemon.impl.analysis.JavaNamesHighlightVisitor; infos:[HighlightInfo(7004,7012); text='@NotNull'; highlighter: (7004,7012); severity=SYMBOL_TYPE_SEVERITY(8); toolId: class com.intellij.codeInsight.daemon.impl.analysis.JavaNamesHighlightVisitor; forcedTextAttributes: [fore=java.awt.Color[r=158,g=136,b=13], back=null, type=0, effect=BOXED]]; oldInfos:[HighlightInfo(7004,7012); severity=SYMBOL_TYPE_SEVERITY(8); toolId: class com.intellij.codeInsight.daemon.impl.analysis.JavaNamesHighlightVisitor; forcedTextAttributes: [fore=java.awt.Color[r=158,g=136,b=13], back=null, type=0, effect=BOXED]] 368637298V
2025-12-16 14:18:17,407 [76242521]  WHISPER - #c.i.c.d.i.HighlightInfoUpdaterImpl - assignRangeHighlighters: pickedup InvalidPsi(PsiJavaCodeReferenceElement:CollectionFactory(7013,7030) {109704164}class com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl,HighlightInfo(7013,7030); text='CollectionFactory'; highlighter: (7013,7030); severity=SYMBOL_TYPE_SEVERITY(8); toolId: class com.intellij.codeInsight.daemon.impl.analysis.JavaNamesHighlightVisitor; forcedTextAttributes: [fore=java.awt.Color[r=0,g=0,b=0], back=null, type=0, effect=BOXED]) from recycler 368637298V
2025-12-16 14:18:17,407 [76242521]  WHISPER - #c.i.c.d.i.HighlightInfoUpdaterImpl - changeRangeHighlighterAttributes: (recycled)HighlightInfo(7013,7030); text='CollectionFactory'; highlighter: (7013,7030); severity=SYMBOL_TYPE_SEVERITY(8); toolId: class com.intellij.codeInsight.daemon.impl.analysis.JavaNamesHighlightVisitor; forcedTextAttributes: [fore=java.awt.Color[r=0,g=0,b=0], back=null, type=0, effect=BOXED] 368637298V
2025-12-16 14:18:17,407 [76242521]  WHISPER - #c.i.c.d.i.HighlightInfoUpdaterImpl - removeFromDataAtomically: PsiJavaCodeReferenceElement:CollectionFactory(7013,7030) {109704164}class com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl: old=1; new=0 368637298V
```

__At last__, I still needed a coffee and a day to decipher what happened, but it boiled down to this.
Highlighters inside the IDE are stored in a complicated data structure which
maps the PSI file currently opened in the editor to the list of tools that were run in this file to highlight its contents - e.g., inspections, annotators, etc.
Each tool entry maps the tool to the list of PSI elements visited by this tool.
And every PSI element links to a list of highlighters generated while this PSI element was visited.

![diagram](assets/diagram.svg)

The link from the `PSI file` to the `tools` is soft, because we don't want to store PSI files longer than necessary.
Likewise, the link from the `PSI element` to the `list of highlighters` is soft too, because we want to retain PSI elements as long as they're still valid, not longer.
Of course, I carefully set up an eviction listener which, as soon as a PSI element is garbage-collected from the map, removes all the associated highlighters.

Turned out, the only problem was that when the `PSI file` disappears, everything it softly referenced disappears too immediately - including the entire map from PSI elements to their associated highlighters -
and that map does not have a single chance either to scream for help or call its own eviction listeners!
Thus, when an entire PSI file gets garbage-collected (which happens surprisingly often), nobody knows that all its PSI elements are gone.
So the highlighters associated with those PSI elements are never destroyed, and continue to live forever, glowing ominously through the grey comments.

Fuck.

Mandatory moral corner:
- I should have feared soft/weak references more. They are too unpredictable in their timing/threading/guarantees behaviour.
- I should have been more cautious with this thing called NI (Natural Intelligence).
  It might look shocking, I know, but I tried to write this code using only biologically based squishy slimy brain cells
  instead of letting an LLM do it for me, like all normal people do.
